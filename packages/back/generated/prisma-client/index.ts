// Code generated by Prisma (prisma@1.32.2). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export type Maybe<T> = T | undefined | null;

export interface Exists {
  category: (where?: CategoryWhereInput) => Promise<boolean>;
  note: (where?: NoteWhereInput) => Promise<boolean>;
  profile: (where?: ProfileWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  category: (where: CategoryWhereUniqueInput) => CategoryNullablePromise;
  categories: (args?: {
    where?: CategoryWhereInput;
    orderBy?: CategoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Category>;
  categoriesConnection: (args?: {
    where?: CategoryWhereInput;
    orderBy?: CategoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CategoryConnectionPromise;
  note: (where: NoteWhereUniqueInput) => NoteNullablePromise;
  notes: (args?: {
    where?: NoteWhereInput;
    orderBy?: NoteOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Note>;
  notesConnection: (args?: {
    where?: NoteWhereInput;
    orderBy?: NoteOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => NoteConnectionPromise;
  profile: (where: ProfileWhereUniqueInput) => ProfileNullablePromise;
  profiles: (args?: {
    where?: ProfileWhereInput;
    orderBy?: ProfileOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Profile>;
  profilesConnection: (args?: {
    where?: ProfileWhereInput;
    orderBy?: ProfileOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ProfileConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserNullablePromise;
  users: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<User>;
  usersConnection: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UserConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createCategory: (data: CategoryCreateInput) => CategoryPromise;
  updateCategory: (args: {
    data: CategoryUpdateInput;
    where: CategoryWhereUniqueInput;
  }) => CategoryPromise;
  updateManyCategories: (args: {
    data: CategoryUpdateManyMutationInput;
    where?: CategoryWhereInput;
  }) => BatchPayloadPromise;
  upsertCategory: (args: {
    where: CategoryWhereUniqueInput;
    create: CategoryCreateInput;
    update: CategoryUpdateInput;
  }) => CategoryPromise;
  deleteCategory: (where: CategoryWhereUniqueInput) => CategoryPromise;
  deleteManyCategories: (where?: CategoryWhereInput) => BatchPayloadPromise;
  createNote: (data: NoteCreateInput) => NotePromise;
  updateNote: (args: {
    data: NoteUpdateInput;
    where: NoteWhereUniqueInput;
  }) => NotePromise;
  updateManyNotes: (args: {
    data: NoteUpdateManyMutationInput;
    where?: NoteWhereInput;
  }) => BatchPayloadPromise;
  upsertNote: (args: {
    where: NoteWhereUniqueInput;
    create: NoteCreateInput;
    update: NoteUpdateInput;
  }) => NotePromise;
  deleteNote: (where: NoteWhereUniqueInput) => NotePromise;
  deleteManyNotes: (where?: NoteWhereInput) => BatchPayloadPromise;
  createProfile: (data: ProfileCreateInput) => ProfilePromise;
  updateProfile: (args: {
    data: ProfileUpdateInput;
    where: ProfileWhereUniqueInput;
  }) => ProfilePromise;
  updateManyProfiles: (args: {
    data: ProfileUpdateManyMutationInput;
    where?: ProfileWhereInput;
  }) => BatchPayloadPromise;
  upsertProfile: (args: {
    where: ProfileWhereUniqueInput;
    create: ProfileCreateInput;
    update: ProfileUpdateInput;
  }) => ProfilePromise;
  deleteProfile: (where: ProfileWhereUniqueInput) => ProfilePromise;
  deleteManyProfiles: (where?: ProfileWhereInput) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (args: {
    data: UserUpdateInput;
    where: UserWhereUniqueInput;
  }) => UserPromise;
  updateManyUsers: (args: {
    data: UserUpdateManyMutationInput;
    where?: UserWhereInput;
  }) => BatchPayloadPromise;
  upsertUser: (args: {
    where: UserWhereUniqueInput;
    create: UserCreateInput;
    update: UserUpdateInput;
  }) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  category: (
    where?: CategorySubscriptionWhereInput
  ) => CategorySubscriptionPayloadSubscription;
  note: (
    where?: NoteSubscriptionWhereInput
  ) => NoteSubscriptionPayloadSubscription;
  profile: (
    where?: ProfileSubscriptionWhereInput
  ) => ProfileSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type NoteOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "title_ASC"
  | "title_DESC"
  | "content_ASC"
  | "content_DESC"
  | "theme_ASC"
  | "theme_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type CategoryOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC";

export type ProfileOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "wechat_ASC"
  | "wechat_DESC"
  | "qq_ASC"
  | "qq_DESC"
  | "weibo_ASC"
  | "weibo_DESC"
  | "zhihu_ASC"
  | "zhihu_DESC"
  | "github_ASC"
  | "github_DESC"
  | "facebook_ASC"
  | "facebook_DESC"
  | "linkin_ASC"
  | "linkin_DESC"
  | "google_ASC"
  | "google_DESC"
  | "juejin_ASC"
  | "juejin_DESC"
  | "avatar_ASC"
  | "avatar_DESC";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "pwd_ASC"
  | "pwd_DESC"
  | "email_ASC"
  | "email_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export interface ProfileUpsertWithoutUserInput {
  update: ProfileUpdateWithoutUserDataInput;
  create: ProfileCreateWithoutUserInput;
}

export type CategoryWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface UserCreateWithoutNotesInput {
  id?: Maybe<ID_Input>;
  name: String;
  pwd: String;
  email: String;
  profile: ProfileCreateOneWithoutUserInput;
}

export interface CategoryUpdateManyDataInput {
  name?: Maybe<String>;
}

export interface ProfileCreateOneWithoutUserInput {
  create?: Maybe<ProfileCreateWithoutUserInput>;
  connect?: Maybe<ProfileWhereUniqueInput>;
}

export interface NoteUpdateManyWithWhereNestedInput {
  where: NoteScalarWhereInput;
  data: NoteUpdateManyDataInput;
}

export interface ProfileCreateWithoutUserInput {
  id?: Maybe<ID_Input>;
  wechat?: Maybe<String>;
  qq?: Maybe<String>;
  weibo?: Maybe<String>;
  zhihu?: Maybe<String>;
  github?: Maybe<String>;
  facebook?: Maybe<String>;
  linkin?: Maybe<String>;
  google?: Maybe<String>;
  juejin?: Maybe<String>;
  avatar?: Maybe<String>;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<UserWhereInput>;
  AND?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  OR?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  NOT?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
}

export interface CategoryUpdateInput {
  name?: Maybe<String>;
  notes?: Maybe<NoteUpdateManyWithoutCategoriesInput>;
}

export interface NoteSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<NoteWhereInput>;
  AND?: Maybe<NoteSubscriptionWhereInput[] | NoteSubscriptionWhereInput>;
  OR?: Maybe<NoteSubscriptionWhereInput[] | NoteSubscriptionWhereInput>;
  NOT?: Maybe<NoteSubscriptionWhereInput[] | NoteSubscriptionWhereInput>;
}

export interface NoteUpdateManyWithoutCategoriesInput {
  create?: Maybe<
    NoteCreateWithoutCategoriesInput[] | NoteCreateWithoutCategoriesInput
  >;
  delete?: Maybe<NoteWhereUniqueInput[] | NoteWhereUniqueInput>;
  connect?: Maybe<NoteWhereUniqueInput[] | NoteWhereUniqueInput>;
  set?: Maybe<NoteWhereUniqueInput[] | NoteWhereUniqueInput>;
  disconnect?: Maybe<NoteWhereUniqueInput[] | NoteWhereUniqueInput>;
  update?: Maybe<
    | NoteUpdateWithWhereUniqueWithoutCategoriesInput[]
    | NoteUpdateWithWhereUniqueWithoutCategoriesInput
  >;
  upsert?: Maybe<
    | NoteUpsertWithWhereUniqueWithoutCategoriesInput[]
    | NoteUpsertWithWhereUniqueWithoutCategoriesInput
  >;
  deleteMany?: Maybe<NoteScalarWhereInput[] | NoteScalarWhereInput>;
  updateMany?: Maybe<
    NoteUpdateManyWithWhereNestedInput[] | NoteUpdateManyWithWhereNestedInput
  >;
}

export interface UserWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  pwd?: Maybe<String>;
  pwd_not?: Maybe<String>;
  pwd_in?: Maybe<String[] | String>;
  pwd_not_in?: Maybe<String[] | String>;
  pwd_lt?: Maybe<String>;
  pwd_lte?: Maybe<String>;
  pwd_gt?: Maybe<String>;
  pwd_gte?: Maybe<String>;
  pwd_contains?: Maybe<String>;
  pwd_not_contains?: Maybe<String>;
  pwd_starts_with?: Maybe<String>;
  pwd_not_starts_with?: Maybe<String>;
  pwd_ends_with?: Maybe<String>;
  pwd_not_ends_with?: Maybe<String>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  profile?: Maybe<ProfileWhereInput>;
  notes_every?: Maybe<NoteWhereInput>;
  notes_some?: Maybe<NoteWhereInput>;
  notes_none?: Maybe<NoteWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<UserWhereInput[] | UserWhereInput>;
  OR?: Maybe<UserWhereInput[] | UserWhereInput>;
  NOT?: Maybe<UserWhereInput[] | UserWhereInput>;
}

export interface NoteUpdateWithWhereUniqueWithoutCategoriesInput {
  where: NoteWhereUniqueInput;
  data: NoteUpdateWithoutCategoriesDataInput;
}

export interface UserUpdateInput {
  name?: Maybe<String>;
  pwd?: Maybe<String>;
  email?: Maybe<String>;
  profile?: Maybe<ProfileUpdateOneRequiredWithoutUserInput>;
  notes?: Maybe<NoteUpdateManyWithoutAuthorInput>;
}

export interface NoteUpdateWithoutCategoriesDataInput {
  title?: Maybe<String>;
  content?: Maybe<String>;
  theme?: Maybe<String>;
  author?: Maybe<UserUpdateOneRequiredWithoutNotesInput>;
}

export interface ProfileUpdateManyMutationInput {
  wechat?: Maybe<String>;
  qq?: Maybe<String>;
  weibo?: Maybe<String>;
  zhihu?: Maybe<String>;
  github?: Maybe<String>;
  facebook?: Maybe<String>;
  linkin?: Maybe<String>;
  google?: Maybe<String>;
  juejin?: Maybe<String>;
  avatar?: Maybe<String>;
}

export interface UserUpdateOneRequiredWithoutNotesInput {
  create?: Maybe<UserCreateWithoutNotesInput>;
  update?: Maybe<UserUpdateWithoutNotesDataInput>;
  upsert?: Maybe<UserUpsertWithoutNotesInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export type NoteWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface UserUpdateWithoutNotesDataInput {
  name?: Maybe<String>;
  pwd?: Maybe<String>;
  email?: Maybe<String>;
  profile?: Maybe<ProfileUpdateOneRequiredWithoutUserInput>;
}

export interface NoteUpdateWithoutAuthorDataInput {
  title?: Maybe<String>;
  content?: Maybe<String>;
  theme?: Maybe<String>;
  categories?: Maybe<CategoryUpdateManyWithoutNotesInput>;
}

export interface ProfileUpdateOneRequiredWithoutUserInput {
  create?: Maybe<ProfileCreateWithoutUserInput>;
  update?: Maybe<ProfileUpdateWithoutUserDataInput>;
  upsert?: Maybe<ProfileUpsertWithoutUserInput>;
  connect?: Maybe<ProfileWhereUniqueInput>;
}

export type ProfileWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface ProfileUpdateWithoutUserDataInput {
  wechat?: Maybe<String>;
  qq?: Maybe<String>;
  weibo?: Maybe<String>;
  zhihu?: Maybe<String>;
  github?: Maybe<String>;
  facebook?: Maybe<String>;
  linkin?: Maybe<String>;
  google?: Maybe<String>;
  juejin?: Maybe<String>;
  avatar?: Maybe<String>;
}

export interface NoteUpdateManyWithoutAuthorInput {
  create?: Maybe<NoteCreateWithoutAuthorInput[] | NoteCreateWithoutAuthorInput>;
  delete?: Maybe<NoteWhereUniqueInput[] | NoteWhereUniqueInput>;
  connect?: Maybe<NoteWhereUniqueInput[] | NoteWhereUniqueInput>;
  set?: Maybe<NoteWhereUniqueInput[] | NoteWhereUniqueInput>;
  disconnect?: Maybe<NoteWhereUniqueInput[] | NoteWhereUniqueInput>;
  update?: Maybe<
    | NoteUpdateWithWhereUniqueWithoutAuthorInput[]
    | NoteUpdateWithWhereUniqueWithoutAuthorInput
  >;
  upsert?: Maybe<
    | NoteUpsertWithWhereUniqueWithoutAuthorInput[]
    | NoteUpsertWithWhereUniqueWithoutAuthorInput
  >;
  deleteMany?: Maybe<NoteScalarWhereInput[] | NoteScalarWhereInput>;
  updateMany?: Maybe<
    NoteUpdateManyWithWhereNestedInput[] | NoteUpdateManyWithWhereNestedInput
  >;
}

export interface UserCreateOneWithoutProfileInput {
  create?: Maybe<UserCreateWithoutProfileInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserUpdateOneRequiredWithoutProfileInput {
  create?: Maybe<UserCreateWithoutProfileInput>;
  update?: Maybe<UserUpdateWithoutProfileDataInput>;
  upsert?: Maybe<UserUpsertWithoutProfileInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserUpsertWithoutNotesInput {
  update: UserUpdateWithoutNotesDataInput;
  create: UserCreateWithoutNotesInput;
}

export interface ProfileUpdateInput {
  user?: Maybe<UserUpdateOneRequiredWithoutProfileInput>;
  wechat?: Maybe<String>;
  qq?: Maybe<String>;
  weibo?: Maybe<String>;
  zhihu?: Maybe<String>;
  github?: Maybe<String>;
  facebook?: Maybe<String>;
  linkin?: Maybe<String>;
  google?: Maybe<String>;
  juejin?: Maybe<String>;
  avatar?: Maybe<String>;
}

export interface NoteUpsertWithWhereUniqueWithoutCategoriesInput {
  where: NoteWhereUniqueInput;
  update: NoteUpdateWithoutCategoriesDataInput;
  create: NoteCreateWithoutCategoriesInput;
}

export interface NoteCreateManyWithoutAuthorInput {
  create?: Maybe<NoteCreateWithoutAuthorInput[] | NoteCreateWithoutAuthorInput>;
  connect?: Maybe<NoteWhereUniqueInput[] | NoteWhereUniqueInput>;
}

export interface NoteScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  content?: Maybe<String>;
  content_not?: Maybe<String>;
  content_in?: Maybe<String[] | String>;
  content_not_in?: Maybe<String[] | String>;
  content_lt?: Maybe<String>;
  content_lte?: Maybe<String>;
  content_gt?: Maybe<String>;
  content_gte?: Maybe<String>;
  content_contains?: Maybe<String>;
  content_not_contains?: Maybe<String>;
  content_starts_with?: Maybe<String>;
  content_not_starts_with?: Maybe<String>;
  content_ends_with?: Maybe<String>;
  content_not_ends_with?: Maybe<String>;
  theme?: Maybe<String>;
  theme_not?: Maybe<String>;
  theme_in?: Maybe<String[] | String>;
  theme_not_in?: Maybe<String[] | String>;
  theme_lt?: Maybe<String>;
  theme_lte?: Maybe<String>;
  theme_gt?: Maybe<String>;
  theme_gte?: Maybe<String>;
  theme_contains?: Maybe<String>;
  theme_not_contains?: Maybe<String>;
  theme_starts_with?: Maybe<String>;
  theme_not_starts_with?: Maybe<String>;
  theme_ends_with?: Maybe<String>;
  theme_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<NoteScalarWhereInput[] | NoteScalarWhereInput>;
  OR?: Maybe<NoteScalarWhereInput[] | NoteScalarWhereInput>;
  NOT?: Maybe<NoteScalarWhereInput[] | NoteScalarWhereInput>;
}

export interface NoteCreateManyWithoutCategoriesInput {
  create?: Maybe<
    NoteCreateWithoutCategoriesInput[] | NoteCreateWithoutCategoriesInput
  >;
  connect?: Maybe<NoteWhereUniqueInput[] | NoteWhereUniqueInput>;
}

export interface CategoryWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  notes_every?: Maybe<NoteWhereInput>;
  notes_some?: Maybe<NoteWhereInput>;
  notes_none?: Maybe<NoteWhereInput>;
  AND?: Maybe<CategoryWhereInput[] | CategoryWhereInput>;
  OR?: Maybe<CategoryWhereInput[] | CategoryWhereInput>;
  NOT?: Maybe<CategoryWhereInput[] | CategoryWhereInput>;
}

export interface UserCreateOneWithoutNotesInput {
  create?: Maybe<UserCreateWithoutNotesInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface NoteUpdateManyDataInput {
  title?: Maybe<String>;
  content?: Maybe<String>;
  theme?: Maybe<String>;
}

export interface ProfileSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ProfileWhereInput>;
  AND?: Maybe<ProfileSubscriptionWhereInput[] | ProfileSubscriptionWhereInput>;
  OR?: Maybe<ProfileSubscriptionWhereInput[] | ProfileSubscriptionWhereInput>;
  NOT?: Maybe<ProfileSubscriptionWhereInput[] | ProfileSubscriptionWhereInput>;
}

export interface CategoryUpdateManyMutationInput {
  name?: Maybe<String>;
}

export interface UserUpdateManyMutationInput {
  name?: Maybe<String>;
  pwd?: Maybe<String>;
  email?: Maybe<String>;
}

export interface ProfileCreateInput {
  id?: Maybe<ID_Input>;
  user: UserCreateOneWithoutProfileInput;
  wechat?: Maybe<String>;
  qq?: Maybe<String>;
  weibo?: Maybe<String>;
  zhihu?: Maybe<String>;
  github?: Maybe<String>;
  facebook?: Maybe<String>;
  linkin?: Maybe<String>;
  google?: Maybe<String>;
  juejin?: Maybe<String>;
  avatar?: Maybe<String>;
}

export interface UserUpsertWithoutProfileInput {
  update: UserUpdateWithoutProfileDataInput;
  create: UserCreateWithoutProfileInput;
}

export interface NoteUpdateManyMutationInput {
  title?: Maybe<String>;
  content?: Maybe<String>;
  theme?: Maybe<String>;
}

export interface NoteUpdateWithWhereUniqueWithoutAuthorInput {
  where: NoteWhereUniqueInput;
  data: NoteUpdateWithoutAuthorDataInput;
}

export interface NoteCreateInput {
  id?: Maybe<ID_Input>;
  title?: Maybe<String>;
  content: String;
  theme?: Maybe<String>;
  author: UserCreateOneWithoutNotesInput;
  categories?: Maybe<CategoryCreateManyWithoutNotesInput>;
}

export interface UserUpdateWithoutProfileDataInput {
  name?: Maybe<String>;
  pwd?: Maybe<String>;
  email?: Maybe<String>;
  notes?: Maybe<NoteUpdateManyWithoutAuthorInput>;
}

export interface CategoryCreateManyWithoutNotesInput {
  create?: Maybe<
    CategoryCreateWithoutNotesInput[] | CategoryCreateWithoutNotesInput
  >;
  connect?: Maybe<CategoryWhereUniqueInput[] | CategoryWhereUniqueInput>;
}

export interface NoteCreateWithoutAuthorInput {
  id?: Maybe<ID_Input>;
  title?: Maybe<String>;
  content: String;
  theme?: Maybe<String>;
  categories?: Maybe<CategoryCreateManyWithoutNotesInput>;
}

export interface CategoryCreateWithoutNotesInput {
  id?: Maybe<ID_Input>;
  name?: Maybe<String>;
}

export interface CategoryCreateInput {
  id?: Maybe<ID_Input>;
  name?: Maybe<String>;
  notes?: Maybe<NoteCreateManyWithoutCategoriesInput>;
}

export interface NoteUpdateInput {
  title?: Maybe<String>;
  content?: Maybe<String>;
  theme?: Maybe<String>;
  author?: Maybe<UserUpdateOneRequiredWithoutNotesInput>;
  categories?: Maybe<CategoryUpdateManyWithoutNotesInput>;
}

export interface ProfileWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  user?: Maybe<UserWhereInput>;
  wechat?: Maybe<String>;
  wechat_not?: Maybe<String>;
  wechat_in?: Maybe<String[] | String>;
  wechat_not_in?: Maybe<String[] | String>;
  wechat_lt?: Maybe<String>;
  wechat_lte?: Maybe<String>;
  wechat_gt?: Maybe<String>;
  wechat_gte?: Maybe<String>;
  wechat_contains?: Maybe<String>;
  wechat_not_contains?: Maybe<String>;
  wechat_starts_with?: Maybe<String>;
  wechat_not_starts_with?: Maybe<String>;
  wechat_ends_with?: Maybe<String>;
  wechat_not_ends_with?: Maybe<String>;
  qq?: Maybe<String>;
  qq_not?: Maybe<String>;
  qq_in?: Maybe<String[] | String>;
  qq_not_in?: Maybe<String[] | String>;
  qq_lt?: Maybe<String>;
  qq_lte?: Maybe<String>;
  qq_gt?: Maybe<String>;
  qq_gte?: Maybe<String>;
  qq_contains?: Maybe<String>;
  qq_not_contains?: Maybe<String>;
  qq_starts_with?: Maybe<String>;
  qq_not_starts_with?: Maybe<String>;
  qq_ends_with?: Maybe<String>;
  qq_not_ends_with?: Maybe<String>;
  weibo?: Maybe<String>;
  weibo_not?: Maybe<String>;
  weibo_in?: Maybe<String[] | String>;
  weibo_not_in?: Maybe<String[] | String>;
  weibo_lt?: Maybe<String>;
  weibo_lte?: Maybe<String>;
  weibo_gt?: Maybe<String>;
  weibo_gte?: Maybe<String>;
  weibo_contains?: Maybe<String>;
  weibo_not_contains?: Maybe<String>;
  weibo_starts_with?: Maybe<String>;
  weibo_not_starts_with?: Maybe<String>;
  weibo_ends_with?: Maybe<String>;
  weibo_not_ends_with?: Maybe<String>;
  zhihu?: Maybe<String>;
  zhihu_not?: Maybe<String>;
  zhihu_in?: Maybe<String[] | String>;
  zhihu_not_in?: Maybe<String[] | String>;
  zhihu_lt?: Maybe<String>;
  zhihu_lte?: Maybe<String>;
  zhihu_gt?: Maybe<String>;
  zhihu_gte?: Maybe<String>;
  zhihu_contains?: Maybe<String>;
  zhihu_not_contains?: Maybe<String>;
  zhihu_starts_with?: Maybe<String>;
  zhihu_not_starts_with?: Maybe<String>;
  zhihu_ends_with?: Maybe<String>;
  zhihu_not_ends_with?: Maybe<String>;
  github?: Maybe<String>;
  github_not?: Maybe<String>;
  github_in?: Maybe<String[] | String>;
  github_not_in?: Maybe<String[] | String>;
  github_lt?: Maybe<String>;
  github_lte?: Maybe<String>;
  github_gt?: Maybe<String>;
  github_gte?: Maybe<String>;
  github_contains?: Maybe<String>;
  github_not_contains?: Maybe<String>;
  github_starts_with?: Maybe<String>;
  github_not_starts_with?: Maybe<String>;
  github_ends_with?: Maybe<String>;
  github_not_ends_with?: Maybe<String>;
  facebook?: Maybe<String>;
  facebook_not?: Maybe<String>;
  facebook_in?: Maybe<String[] | String>;
  facebook_not_in?: Maybe<String[] | String>;
  facebook_lt?: Maybe<String>;
  facebook_lte?: Maybe<String>;
  facebook_gt?: Maybe<String>;
  facebook_gte?: Maybe<String>;
  facebook_contains?: Maybe<String>;
  facebook_not_contains?: Maybe<String>;
  facebook_starts_with?: Maybe<String>;
  facebook_not_starts_with?: Maybe<String>;
  facebook_ends_with?: Maybe<String>;
  facebook_not_ends_with?: Maybe<String>;
  linkin?: Maybe<String>;
  linkin_not?: Maybe<String>;
  linkin_in?: Maybe<String[] | String>;
  linkin_not_in?: Maybe<String[] | String>;
  linkin_lt?: Maybe<String>;
  linkin_lte?: Maybe<String>;
  linkin_gt?: Maybe<String>;
  linkin_gte?: Maybe<String>;
  linkin_contains?: Maybe<String>;
  linkin_not_contains?: Maybe<String>;
  linkin_starts_with?: Maybe<String>;
  linkin_not_starts_with?: Maybe<String>;
  linkin_ends_with?: Maybe<String>;
  linkin_not_ends_with?: Maybe<String>;
  google?: Maybe<String>;
  google_not?: Maybe<String>;
  google_in?: Maybe<String[] | String>;
  google_not_in?: Maybe<String[] | String>;
  google_lt?: Maybe<String>;
  google_lte?: Maybe<String>;
  google_gt?: Maybe<String>;
  google_gte?: Maybe<String>;
  google_contains?: Maybe<String>;
  google_not_contains?: Maybe<String>;
  google_starts_with?: Maybe<String>;
  google_not_starts_with?: Maybe<String>;
  google_ends_with?: Maybe<String>;
  google_not_ends_with?: Maybe<String>;
  juejin?: Maybe<String>;
  juejin_not?: Maybe<String>;
  juejin_in?: Maybe<String[] | String>;
  juejin_not_in?: Maybe<String[] | String>;
  juejin_lt?: Maybe<String>;
  juejin_lte?: Maybe<String>;
  juejin_gt?: Maybe<String>;
  juejin_gte?: Maybe<String>;
  juejin_contains?: Maybe<String>;
  juejin_not_contains?: Maybe<String>;
  juejin_starts_with?: Maybe<String>;
  juejin_not_starts_with?: Maybe<String>;
  juejin_ends_with?: Maybe<String>;
  juejin_not_ends_with?: Maybe<String>;
  avatar?: Maybe<String>;
  avatar_not?: Maybe<String>;
  avatar_in?: Maybe<String[] | String>;
  avatar_not_in?: Maybe<String[] | String>;
  avatar_lt?: Maybe<String>;
  avatar_lte?: Maybe<String>;
  avatar_gt?: Maybe<String>;
  avatar_gte?: Maybe<String>;
  avatar_contains?: Maybe<String>;
  avatar_not_contains?: Maybe<String>;
  avatar_starts_with?: Maybe<String>;
  avatar_not_starts_with?: Maybe<String>;
  avatar_ends_with?: Maybe<String>;
  avatar_not_ends_with?: Maybe<String>;
  AND?: Maybe<ProfileWhereInput[] | ProfileWhereInput>;
  OR?: Maybe<ProfileWhereInput[] | ProfileWhereInput>;
  NOT?: Maybe<ProfileWhereInput[] | ProfileWhereInput>;
}

export interface CategoryUpdateManyWithoutNotesInput {
  create?: Maybe<
    CategoryCreateWithoutNotesInput[] | CategoryCreateWithoutNotesInput
  >;
  delete?: Maybe<CategoryWhereUniqueInput[] | CategoryWhereUniqueInput>;
  connect?: Maybe<CategoryWhereUniqueInput[] | CategoryWhereUniqueInput>;
  set?: Maybe<CategoryWhereUniqueInput[] | CategoryWhereUniqueInput>;
  disconnect?: Maybe<CategoryWhereUniqueInput[] | CategoryWhereUniqueInput>;
  update?: Maybe<
    | CategoryUpdateWithWhereUniqueWithoutNotesInput[]
    | CategoryUpdateWithWhereUniqueWithoutNotesInput
  >;
  upsert?: Maybe<
    | CategoryUpsertWithWhereUniqueWithoutNotesInput[]
    | CategoryUpsertWithWhereUniqueWithoutNotesInput
  >;
  deleteMany?: Maybe<CategoryScalarWhereInput[] | CategoryScalarWhereInput>;
  updateMany?: Maybe<
    | CategoryUpdateManyWithWhereNestedInput[]
    | CategoryUpdateManyWithWhereNestedInput
  >;
}

export interface UserCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  pwd: String;
  email: String;
  profile: ProfileCreateOneWithoutUserInput;
  notes?: Maybe<NoteCreateManyWithoutAuthorInput>;
}

export interface CategoryUpdateWithWhereUniqueWithoutNotesInput {
  where: CategoryWhereUniqueInput;
  data: CategoryUpdateWithoutNotesDataInput;
}

export interface NoteWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  content?: Maybe<String>;
  content_not?: Maybe<String>;
  content_in?: Maybe<String[] | String>;
  content_not_in?: Maybe<String[] | String>;
  content_lt?: Maybe<String>;
  content_lte?: Maybe<String>;
  content_gt?: Maybe<String>;
  content_gte?: Maybe<String>;
  content_contains?: Maybe<String>;
  content_not_contains?: Maybe<String>;
  content_starts_with?: Maybe<String>;
  content_not_starts_with?: Maybe<String>;
  content_ends_with?: Maybe<String>;
  content_not_ends_with?: Maybe<String>;
  theme?: Maybe<String>;
  theme_not?: Maybe<String>;
  theme_in?: Maybe<String[] | String>;
  theme_not_in?: Maybe<String[] | String>;
  theme_lt?: Maybe<String>;
  theme_lte?: Maybe<String>;
  theme_gt?: Maybe<String>;
  theme_gte?: Maybe<String>;
  theme_contains?: Maybe<String>;
  theme_not_contains?: Maybe<String>;
  theme_starts_with?: Maybe<String>;
  theme_not_starts_with?: Maybe<String>;
  theme_ends_with?: Maybe<String>;
  theme_not_ends_with?: Maybe<String>;
  author?: Maybe<UserWhereInput>;
  categories_every?: Maybe<CategoryWhereInput>;
  categories_some?: Maybe<CategoryWhereInput>;
  categories_none?: Maybe<CategoryWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<NoteWhereInput[] | NoteWhereInput>;
  OR?: Maybe<NoteWhereInput[] | NoteWhereInput>;
  NOT?: Maybe<NoteWhereInput[] | NoteWhereInput>;
}

export interface CategoryUpdateManyWithWhereNestedInput {
  where: CategoryScalarWhereInput;
  data: CategoryUpdateManyDataInput;
}

export interface CategoryScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  AND?: Maybe<CategoryScalarWhereInput[] | CategoryScalarWhereInput>;
  OR?: Maybe<CategoryScalarWhereInput[] | CategoryScalarWhereInput>;
  NOT?: Maybe<CategoryScalarWhereInput[] | CategoryScalarWhereInput>;
}

export interface CategoryUpsertWithWhereUniqueWithoutNotesInput {
  where: CategoryWhereUniqueInput;
  update: CategoryUpdateWithoutNotesDataInput;
  create: CategoryCreateWithoutNotesInput;
}

export interface CategoryUpdateWithoutNotesDataInput {
  name?: Maybe<String>;
}

export type UserWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  email?: Maybe<String>;
}>;

export interface NoteUpsertWithWhereUniqueWithoutAuthorInput {
  where: NoteWhereUniqueInput;
  update: NoteUpdateWithoutAuthorDataInput;
  create: NoteCreateWithoutAuthorInput;
}

export interface CategorySubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CategoryWhereInput>;
  AND?: Maybe<
    CategorySubscriptionWhereInput[] | CategorySubscriptionWhereInput
  >;
  OR?: Maybe<CategorySubscriptionWhereInput[] | CategorySubscriptionWhereInput>;
  NOT?: Maybe<
    CategorySubscriptionWhereInput[] | CategorySubscriptionWhereInput
  >;
}

export interface NoteCreateWithoutCategoriesInput {
  id?: Maybe<ID_Input>;
  title?: Maybe<String>;
  content: String;
  theme?: Maybe<String>;
  author: UserCreateOneWithoutNotesInput;
}

export interface UserCreateWithoutProfileInput {
  id?: Maybe<ID_Input>;
  name: String;
  pwd: String;
  email: String;
  notes?: Maybe<NoteCreateManyWithoutAuthorInput>;
}

export interface NodeNode {
  id: ID_Output;
}

export interface UserPreviousValues {
  id: ID_Output;
  name: String;
  pwd: String;
  email: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  pwd: () => Promise<String>;
  email: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  pwd: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface CategoryEdge {
  node: Category;
  cursor: String;
}

export interface CategoryEdgePromise
  extends Promise<CategoryEdge>,
    Fragmentable {
  node: <T = CategoryPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CategoryEdgeSubscription
  extends Promise<AsyncIterator<CategoryEdge>>,
    Fragmentable {
  node: <T = CategorySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ProfileSubscriptionPayload {
  mutation: MutationType;
  node: Profile;
  updatedFields: String[];
  previousValues: ProfilePreviousValues;
}

export interface ProfileSubscriptionPayloadPromise
  extends Promise<ProfileSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ProfilePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ProfilePreviousValuesPromise>() => T;
}

export interface ProfileSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ProfileSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ProfileSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ProfilePreviousValuesSubscription>() => T;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface CategoryConnection {
  pageInfo: PageInfo;
  edges: CategoryEdge[];
}

export interface CategoryConnectionPromise
  extends Promise<CategoryConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CategoryEdge>>() => T;
  aggregate: <T = AggregateCategoryPromise>() => T;
}

export interface CategoryConnectionSubscription
  extends Promise<AsyncIterator<CategoryConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CategoryEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCategorySubscription>() => T;
}

export interface AggregateProfile {
  count: Int;
}

export interface AggregateProfilePromise
  extends Promise<AggregateProfile>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateProfileSubscription
  extends Promise<AsyncIterator<AggregateProfile>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Profile {
  id: ID_Output;
  wechat?: String;
  qq?: String;
  weibo?: String;
  zhihu?: String;
  github?: String;
  facebook?: String;
  linkin?: String;
  google?: String;
  juejin?: String;
  avatar?: String;
}

export interface ProfilePromise extends Promise<Profile>, Fragmentable {
  id: () => Promise<ID_Output>;
  user: <T = UserPromise>() => T;
  wechat: () => Promise<String>;
  qq: () => Promise<String>;
  weibo: () => Promise<String>;
  zhihu: () => Promise<String>;
  github: () => Promise<String>;
  facebook: () => Promise<String>;
  linkin: () => Promise<String>;
  google: () => Promise<String>;
  juejin: () => Promise<String>;
  avatar: () => Promise<String>;
}

export interface ProfileSubscription
  extends Promise<AsyncIterator<Profile>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  user: <T = UserSubscription>() => T;
  wechat: () => Promise<AsyncIterator<String>>;
  qq: () => Promise<AsyncIterator<String>>;
  weibo: () => Promise<AsyncIterator<String>>;
  zhihu: () => Promise<AsyncIterator<String>>;
  github: () => Promise<AsyncIterator<String>>;
  facebook: () => Promise<AsyncIterator<String>>;
  linkin: () => Promise<AsyncIterator<String>>;
  google: () => Promise<AsyncIterator<String>>;
  juejin: () => Promise<AsyncIterator<String>>;
  avatar: () => Promise<AsyncIterator<String>>;
}

export interface ProfileNullablePromise
  extends Promise<Profile | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  user: <T = UserPromise>() => T;
  wechat: () => Promise<String>;
  qq: () => Promise<String>;
  weibo: () => Promise<String>;
  zhihu: () => Promise<String>;
  github: () => Promise<String>;
  facebook: () => Promise<String>;
  linkin: () => Promise<String>;
  google: () => Promise<String>;
  juejin: () => Promise<String>;
  avatar: () => Promise<String>;
}

export interface ProfileConnection {
  pageInfo: PageInfo;
  edges: ProfileEdge[];
}

export interface ProfileConnectionPromise
  extends Promise<ProfileConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ProfileEdge>>() => T;
  aggregate: <T = AggregateProfilePromise>() => T;
}

export interface ProfileConnectionSubscription
  extends Promise<AsyncIterator<ProfileConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ProfileEdgeSubscription>>>() => T;
  aggregate: <T = AggregateProfileSubscription>() => T;
}

export interface Category {
  id: ID_Output;
  name?: String;
}

export interface CategoryPromise extends Promise<Category>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  notes: <T = FragmentableArray<Note>>(args?: {
    where?: NoteWhereInput;
    orderBy?: NoteOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface CategorySubscription
  extends Promise<AsyncIterator<Category>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  notes: <T = Promise<AsyncIterator<NoteSubscription>>>(args?: {
    where?: NoteWhereInput;
    orderBy?: NoteOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface CategoryNullablePromise
  extends Promise<Category | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  notes: <T = FragmentableArray<Note>>(args?: {
    where?: NoteWhereInput;
    orderBy?: NoteOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface NoteEdge {
  node: Note;
  cursor: String;
}

export interface NoteEdgePromise extends Promise<NoteEdge>, Fragmentable {
  node: <T = NotePromise>() => T;
  cursor: () => Promise<String>;
}

export interface NoteEdgeSubscription
  extends Promise<AsyncIterator<NoteEdge>>,
    Fragmentable {
  node: <T = NoteSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CategorySubscriptionPayload {
  mutation: MutationType;
  node: Category;
  updatedFields: String[];
  previousValues: CategoryPreviousValues;
}

export interface CategorySubscriptionPayloadPromise
  extends Promise<CategorySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CategoryPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CategoryPreviousValuesPromise>() => T;
}

export interface CategorySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CategorySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CategorySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CategoryPreviousValuesSubscription>() => T;
}

export interface AggregateCategory {
  count: Int;
}

export interface AggregateCategoryPromise
  extends Promise<AggregateCategory>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCategorySubscription
  extends Promise<AsyncIterator<AggregateCategory>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CategoryPreviousValues {
  id: ID_Output;
  name?: String;
}

export interface CategoryPreviousValuesPromise
  extends Promise<CategoryPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface CategoryPreviousValuesSubscription
  extends Promise<AsyncIterator<CategoryPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Note {
  id: ID_Output;
  title?: String;
  content: String;
  theme?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface NotePromise extends Promise<Note>, Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  content: () => Promise<String>;
  theme: () => Promise<String>;
  author: <T = UserPromise>() => T;
  categories: <T = FragmentableArray<Category>>(args?: {
    where?: CategoryWhereInput;
    orderBy?: CategoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface NoteSubscription
  extends Promise<AsyncIterator<Note>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  content: () => Promise<AsyncIterator<String>>;
  theme: () => Promise<AsyncIterator<String>>;
  author: <T = UserSubscription>() => T;
  categories: <T = Promise<AsyncIterator<CategorySubscription>>>(args?: {
    where?: CategoryWhereInput;
    orderBy?: CategoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface NoteNullablePromise
  extends Promise<Note | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  content: () => Promise<String>;
  theme: () => Promise<String>;
  author: <T = UserPromise>() => T;
  categories: <T = FragmentableArray<Category>>(args?: {
    where?: CategoryWhereInput;
    orderBy?: CategoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface NotePreviousValues {
  id: ID_Output;
  title?: String;
  content: String;
  theme?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface NotePreviousValuesPromise
  extends Promise<NotePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  content: () => Promise<String>;
  theme: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface NotePreviousValuesSubscription
  extends Promise<AsyncIterator<NotePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  content: () => Promise<AsyncIterator<String>>;
  theme: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface NoteSubscriptionPayload {
  mutation: MutationType;
  node: Note;
  updatedFields: String[];
  previousValues: NotePreviousValues;
}

export interface NoteSubscriptionPayloadPromise
  extends Promise<NoteSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = NotePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = NotePreviousValuesPromise>() => T;
}

export interface NoteSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<NoteSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = NoteSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = NotePreviousValuesSubscription>() => T;
}

export interface User {
  id: ID_Output;
  name: String;
  pwd: String;
  email: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  pwd: () => Promise<String>;
  email: () => Promise<String>;
  profile: <T = ProfilePromise>() => T;
  notes: <T = FragmentableArray<Note>>(args?: {
    where?: NoteWhereInput;
    orderBy?: NoteOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  pwd: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  profile: <T = ProfileSubscription>() => T;
  notes: <T = Promise<AsyncIterator<NoteSubscription>>>(args?: {
    where?: NoteWhereInput;
    orderBy?: NoteOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface UserNullablePromise
  extends Promise<User | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  pwd: () => Promise<String>;
  email: () => Promise<String>;
  profile: <T = ProfilePromise>() => T;
  notes: <T = FragmentableArray<Note>>(args?: {
    where?: NoteWhereInput;
    orderBy?: NoteOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ProfilePreviousValues {
  id: ID_Output;
  wechat?: String;
  qq?: String;
  weibo?: String;
  zhihu?: String;
  github?: String;
  facebook?: String;
  linkin?: String;
  google?: String;
  juejin?: String;
  avatar?: String;
}

export interface ProfilePreviousValuesPromise
  extends Promise<ProfilePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  wechat: () => Promise<String>;
  qq: () => Promise<String>;
  weibo: () => Promise<String>;
  zhihu: () => Promise<String>;
  github: () => Promise<String>;
  facebook: () => Promise<String>;
  linkin: () => Promise<String>;
  google: () => Promise<String>;
  juejin: () => Promise<String>;
  avatar: () => Promise<String>;
}

export interface ProfilePreviousValuesSubscription
  extends Promise<AsyncIterator<ProfilePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  wechat: () => Promise<AsyncIterator<String>>;
  qq: () => Promise<AsyncIterator<String>>;
  weibo: () => Promise<AsyncIterator<String>>;
  zhihu: () => Promise<AsyncIterator<String>>;
  github: () => Promise<AsyncIterator<String>>;
  facebook: () => Promise<AsyncIterator<String>>;
  linkin: () => Promise<AsyncIterator<String>>;
  google: () => Promise<AsyncIterator<String>>;
  juejin: () => Promise<AsyncIterator<String>>;
  avatar: () => Promise<AsyncIterator<String>>;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface NoteConnection {
  pageInfo: PageInfo;
  edges: NoteEdge[];
}

export interface NoteConnectionPromise
  extends Promise<NoteConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<NoteEdge>>() => T;
  aggregate: <T = AggregateNotePromise>() => T;
}

export interface NoteConnectionSubscription
  extends Promise<AsyncIterator<NoteConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<NoteEdgeSubscription>>>() => T;
  aggregate: <T = AggregateNoteSubscription>() => T;
}

export interface AggregateNote {
  count: Int;
}

export interface AggregateNotePromise
  extends Promise<AggregateNote>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateNoteSubscription
  extends Promise<AsyncIterator<AggregateNote>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ProfileEdge {
  node: Profile;
  cursor: String;
}

export interface ProfileEdgePromise extends Promise<ProfileEdge>, Fragmentable {
  node: <T = ProfilePromise>() => T;
  cursor: () => Promise<String>;
}

export interface ProfileEdgeSubscription
  extends Promise<AsyncIterator<ProfileEdge>>,
    Fragmentable {
  node: <T = ProfileSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

export type Long = string;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. 
*/
export type Int = number;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "User",
    embedded: false
  },
  {
    name: "Profile",
    embedded: false
  },
  {
    name: "Note",
    embedded: false
  },
  {
    name: "Category",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const Prisma = makePrismaClientClass<ClientConstructor<Prisma>>({
  typeDefs,
  models,
  endpoint: `http://localhost:44661`
});
export const prisma = new Prisma();
